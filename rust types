*ðŸ§± Primitive Scalar Types*
These hold single values.

- `i8`, `i16`, `i32`, `i64`, `i128`, `isize` â†’ Signed integers
- `u8`, `u16`, `u32`, `u64`, `u128`, `usize` â†’ Unsigned integers
- `f32`, `f64` â†’ Floating point numbers
- `char` â†’ A single Unicode character (`'a'`, `'Ï€'`, `'ðŸš€'`)
- `bool` â†’ `true` or `false`

---

*ðŸ§± Primitive Compound Types*
These group multiple values together.

- *Tuple*: `(i32, f64, char)` â€” fixed-size, heterogenous
- *Array*: `[i32; 3]` â€” fixed-size, same type

---

*ðŸ“¦ Standard Library Types*
These are heap-allocated and flexible.

- `String` â†’ Growable, owned, heap-allocated string
- `&str` â†’ String slice (usually borrowed from a `String`)
- `Vec<T>` â†’ Growable list of values
- `Option<T>` â†’ Either `Some(value)` or `None`
- `Result<T, E>` â†’ For error handling: `Ok(value)` or `Err(error)`
- `Box<T>` â†’ Heap allocation for single values
- `Rc<T>` â†’ Reference-counted pointer (shared ownership)
- `Arc<T>` â†’ Atomic reference-counted pointer (thread-safe)
- `HashMap<K, V>` â†’ Key-value dictionary
- `HashSet<T>` â†’ Collection of unique values

---

*ðŸ‘¤ User-Defined Types*
You can create your own types using:

- `struct` â†’ Custom data structures
- `enum` â†’ Custom enums like `enum Direction { North, South}`
- `union` â†’ Unsafe, overlapping memory layout for multiple fields
- `type` â†’ Type aliases (`type Kilometers = i32`)

---

*ðŸ“š Trait Types*
Traits define shared behavior and are used with generics:

- Built-in traits like `Copy`, `Clone`, `Debug`, `PartialEq`, `Drop`, etc.
- Custom traits: `trait Speak { fn speak(&self);}`

---

*ðŸ§™â€â™‚ï¸ Function Types & Closures*
You can use:

- Function pointers: `fn(i32) -> i32`
- Closures: `let add = |x, y| x + y;`

---

*ðŸ¦º Smart Pointer/Concurrency Types*
For advanced memory and thread control:

- `RefCell<T>` and `Cell<T>` â€” runtime-checked borrowing
- `Mutex<T>`, `RwLock<T>` â€” thread-safe interior mutability
- `Atomic*` â€” low-level atomics (e.g., `AtomicUsize`)